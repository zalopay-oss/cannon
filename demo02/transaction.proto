syntax = "proto3";
option java_multiple_files = true;
option java_package = "vn.zalopay.zas.protobuf";
option go_package = "zas_protobuf";
package zas.protobuf;


enum TransStatus {
  TRANS_STATUS_UNKNOWN = 0;
  // Request is received
  TRANS_STATUS_RECEIVED = 1;
  // Request is processing
  TRANS_STATUS_PROCESSING = 2;
  // Request is process successfully
  TRANS_STATUS_SUCCESSFUL = 3;
  // Request is process failed
  TRANS_STATUS_FAILED = 4;
}

enum EntryType {
  IN_OUT = 0;
  DEBIT_CREDIT = 1;
}

// Journal entry
//
// This structure represents information needed to move money/value 
// from a source account to a destination one.
// 
// An entry has an associated type.
// + DEBIT_CREDIT: suitable for Accountant view. 
//     Debit/credit records has different meaning to assets or liabilities
//     
// + IN_OUT: (easy for Developer to integrate)
//    IN_OUT entries will be implicitly translated to DEBIT_CREDIT ones (using Account Code)
message Entry {
  // Default is DEBIT_CREDIT
  EntryType type = 1;

  // REQUIRED
  // OUT or DEBIT
  // ZaloPay Accounting ID
  int64 source_id = 2;

  // REQUIRED
  // IN or CREDIT
  // ZaloPay Accounting ID
  int64 destination_id = 3;

  // REQUIRED
  int64 amount = 4;

  // Optional, default is 704 (Vietnamese Dong)
  // Reference: https://en.wikipedia.org/wiki/ISO_4217
  int32 currency_code = 5;

  // Optional
  map<string, string> extra = 6;
}

message TransRecordRequest{
  // REQUIRED
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;

  // REQUIRED
  // The origin transaction number of PaymentCore,...of 
  string trans_id = 2;

  // REQUIRED
  // List of entries to process 
  repeated Entry entries = 3;

  // REQUIRED
  // Information associated with a transaction
  zas.protobuf.TransEnvironment environment = 4;

  // Optional
  // You can provide addional tags to provide rich-query capabilities
  //
  // Tags should have the following format (like Docker tags):  
  //    <key1>=<value1>[,<key2>=<value2>]
  string tags = 5;
}

message TransRecordResponse {
  message Data{
    Transaction transaction = 1;

    // The current account balance state of all account effected by this transaction
    repeated Account accounts = 2;    
  }
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;

  // Error response include code and message
  Error error = 2;
  Data data = 3; 
}

// Batch must be execute in order and a batch is not a transaction, the record is a transaction
message TransRecordBatchRequest {
  // REQUIRED
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;
  repeated TransRecordRequest records = 2;
}

message TransRecordBatchResponse {
  int64 timestamp = 1;
  repeated TransRecordResponse reponses = 2;
}

message TransQueryRequest {
  // Optional
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1; 

  oneof query_by {
    // Transaction number of ZAS. 
    // This field is prefer
    string voucher_id = 2;
  
    // Provided trans_id in the associated request
    string trans_id = 3;

    // tag of transactions
    // in the form of <key1>=<value1>
    string tag = 4;
  }

  // Optional
  // If field not set, ZAS will get system_id from token associated to a client
  int32 system_id = 5;

  // for paging (optional, used when query by tags)
  int64 offset = 6; // default: 0
  int64 count = 7; // default: 10
}

message TransQueryResponse {
  message Data{
    repeated Transaction transactions = 1;  
    int64 total = 2; // total of transaction
  }
  
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;

  // Error response include code and message
  Error error = 2;
  
  // Transaction data response
  Data data = 3;
}

message Transaction {
  // Transaction number of ZAS
  string voucher_id = 1;

  // Provided trans_id in the associated request
  string trans_id = 2;

  // Transaction status
  TransStatus status = 3;

  // Origin request 
  TransRecordRequest request = 4;

  string tags = 5;

  // Optional
  map<string, string> extra = 6;
}

message TransRevertRequest {
  // Optional
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1; 

  oneof reverted_by {
    // Transaction number of ZAS. 
    // This field is prefer
    string voucher_id = 2;
  
    // Provided trans_id in the associated request
    string trans_id = 3;
  }

  // Optional
  // If field not set, ZAS will get system_id from token associated to a client
  int32 system_id = 4;
 
  // Optional
  // List of entries to update
  repeated Entry entries = 5;

  // Information associated with a transaction
  zas.protobuf.TransEnvironment environment = 6;
}

message TransRevertResponse {
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;
  Error error = 2;
  Transaction data = 3;
}


service TransactionService {
  // Process transaction, such as topup, transfer user to user...
  //
  // Return:
  //  If the trans_id already exists, returns `ALREADY_EXISTS`.
  //  If any field require not set,  returns `INVALID_ARGUMENT`.
  //  If account balance is not enough or user is not exists, return `FAILED_PRECONDITION`.
  //  If account in record not exists, return 'NOT_FOUND'
  //  If create account successful, returns `SUCCESS` and account information.
  rpc transRecord(TransRecordRequest) returns (TransRecordResponse) ;

  // This function is just available on migration phase only
  // Process transaction by batch
  // A batch is not a transaction, the record is transaction
  // A batch must execute in order, if a record fail, continue with next record
  //
  // Return:
  //  If the trans_id already exists, returns `ALREADY_EXISTS`.
  //  If any field require not set,  returns `INVALID_ARGUMENT`.
  //  If account balance is not enough or user is not exists, return `FAILED_PRECONDITION`.
  //  If account in record not exists, return 'NOT_FOUND'
  //  If create account successful, returns `SUCCESS` and account information.
  rpc transRecordBatch(TransRecordBatchRequest) returns (TransRecordBatchResponse) ;

  // Query information about a transacton
  //
  // Return:
  //  If any field require not set, returns `INVALID_ARGUMENT`.
  //  If transaction not found, returns `NOT_FOUND`
  //  If query account successful, returns `SUCCESS` and transacton information
  rpc transQuery(TransQueryRequest) returns (TransQueryResponse);


  // Revert a transaction in the database 
  // Api is only used with admin role and just enable in migrate data phase only
  //
  // Return:
  //    If any field require not set, returns `INVALID_ARGUMENT`.
  //    If transaction not found, returns `NOT_FOUND`.
  //    If transaction revert successful, returns `SUCCESS`.
  //    If there is a cause make transaction can not be revert like 
  //    account balance is not enough, return `FAILED_PRECONDITION`.
  //    If callers are not authenticated/authorized, returns `PERMISSION_DENIED`.
  rpc transRevert(TransRevertRequest) returns (TransRevertResponse);

}


// ===
enum AccountStatus {
  ACCOUNT_ENABLED = 0;
  ACCOUNT_DISABLED = 1;
}

message Account {
  // REQUIRED
  // ZaloPay Accounting System ID (ZAS ID for short)
  int64 id = 1;

  // REQUIRED
  // The ledger to which this account belongs
  int32 ledger_id = 2;
  string ledger_accounting_code = 3;

  // REQUIRED
  // Unique identifier provided by external systems
  string uid = 4;

  // Optional, default is 704 (Vietnamese Dong)
  // Reference: https://en.wikipedia.org/wiki/ISO_4217
  int32 currency_code = 5;

  // Optional, default is ENABLED
  AccountStatus status = 6;

  string tags = 7;

  // current realtime account balance
  int64 balance = 8;

  int64 created_time = 9;
  int64 modified_time = 10;

  // current account balance version
  int64 version = 11;
 
  // Optional
  map<string, string> extra = 12;
}

message LedgerGroup {
  repeated string accounting_code = 1;
}

message AccountCreateRequest {
  // Optional
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;
 
  oneof created_by{
    // For available ledger tags, please consult ledger.proto
    string ledger_tag = 2;

    // If ledger_tag is empty, we can specify a group of ledgers featured by their accounting codes
    LedgerGroup ledger_group = 3;
  }

  // REQUIRED
  // Unique identifier provided by external systems
  string uid = 4;

  // Optional
  // You can provide addional tags to provide rich-query capabilities
  //
  // Tags should have the following format (like Docker tags):  
  //    <key1>=<value1>[,<key2>=<value2>]
  string tags = 5;

  // Optional
  map<string, string> extra = 6;
}

message AccountCreateResponse {
  message Data {
    repeated Account accounts = 1;
  }

  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;

  // Error response include code and message
  Error error = 2;

  // Data response when create account successful
  // List account
  Data data = 3;
}

message AccountQueryRequest{
  // Optional. Default -1
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;

  oneof query_by {
    // Query by account fields 
    //
    // If no tag is provided, this field is used
    // ZaloPay Accounting System ID (ZAS ID for short)
    int64 id = 2;
    //
    // tag of accounts
    // in the form of <key1>=<value1>
    string tag = 3;

    // Query by ledger fields 
    //
    // Ledger tag
    // For available ledger tags, please consult ledger.proto
    string ledger_tag = 4;
    //
    // Ledger accounting code
    string ledger_accounting_code = 5;
  }
 
  // for paging (optional, used when query by tags & accounting codes)
  int64 offset = 6; // default: 0
  int64 count = 7; // default: 10

  // system id (optional, default get by current system request)
  int32 system_id = 8;
}

message AccountQueryResponse {
  message Data {
    // Accounts infomation response
    repeated Account accounts = 1;
    int64 total = 2;
  }

  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;
  // Error response include code and message
  Error error = 2;

  // Data response when process successful
  // List account
  Data data = 3;
}


message AccountUpdateRequest {
  // Optional. Default -1
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;

  // List of accounts to be updated
  // You can ONLY update following fields in Account record:
  //  - tag
  //  - status
  //  - extra
  repeated Account accounts = 2;

    // Make those account to hot and split balance to the sub-accounts.
  // Defaut = false
  bool is_hot = 3;

  // Number of sub-account belongs to each hot-account.
  // Default = 128
  int32 number_of_sub_accounts = 4;
}

message AccountUpdateResponse {
  message Data { repeated Account accounts = 1; }

  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;
  Error error = 2;
  Data data = 3;
}

message AccountListRequest {
  // Optional. Default -1
  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;

  // REQUIRED
  // List all accounts belong to a ledger
  int32 ledger_id = 2;
  
  // for paging (optional)
  // default = 0
  int64 offset = 3;

  // default = 10
  // maximum: 100
  int64 count = 4;
}

message AccountListResponse {
  message Data { 
    // Selectd accounts
    repeated Account accounts = 1;
    // Total number of accounts by account account ledger
    // This field can be used pagination in zas-mine
    int64 total = 2; 
  }

  // This field can be used to track request-reponse latencies
  int64 timestamp = 1;
  Error error = 2;
  Data data = 3;
}

service AccountService{
  // Create accounts from the requested.
  //
  // Return: 
  //    If the account already exists, returns `ALREADY_EXISTS`.
  //    If any field require not set or ledger_id not exists, returns `INVALID_ARGUMENT`.
  //    If create account successful, returns `SUCCESS` and account information.
  //    If callers are not authenticated/authorized, returns `PERMISSION_DENIED`.
  //    With role = "user", user can't creare account bank, merchant
  rpc accountCreate(AccountCreateRequest) returns (AccountCreateResponse) ;

  // Query information about accounts.
  //
  // Return:
  //    If any field require not set or ledger_id not exists, returns `INVALID_ARGUMENT`.
  //    If account not found, returns `NOT_FOUND`.
  //    If query account successful, returns `SUCCESS` and accounts information.
  rpc accountQuery(AccountQueryRequest) returns (AccountQueryResponse);
  
  // Update accounts's information.
  //
  // Return:
  //    If any field require not set or ledger_id not exists, returns `INVALID_ARGUMENT`.
  //    If account not found, returns `NOT_FOUND`.
  //    If update account successful, returns `SUCCESS` and list accounts.
  //    If callers are not authenticated/authorized, returns `PERMISSION_DENIED`.
  //    With role = "user", user can't update account bank, merchant
  rpc accountUpdate(AccountUpdateRequest) returns (AccountUpdateResponse);

  // Listerate all available accounts. 
  // Api is only used with admin role
  //
  // Return:
  //    If any field require not set, returns `INVALID_ARGUMENT`.
  //    If get list account successful, returns `SUCCESS` and list accounts.
  //    If callers are not authenticated/authorized, returns `PERMISSION_DENIED`.
  rpc accountList(AccountListRequest) returns (AccountListResponse) ;
}

// ===

message Context {
  string reconciliation = 1;
}

// Transaction Context Information
message TransEnvironment {
  // Optional. Default v1.0
  string version = 1;

  // REQUIRED
  int64 accounting_time = 2;

  // REQUIRED
  // TODO: Check if this field is required
  string global_trans_id = 3;

  // REQUIRED
  // Flow id
  string flow_id = 4;

  // Optional for Reconcile
  // TransContext data
  Context contexts = 5;

  // Optional for Reconcile
  string bank_account = 6;

  map<string, string> extra = 9;
}


//===

message Error {
  // code = 0 means success
  zas.protobuf.Code code = 1;
  string message = 2;
  map<string, string> extra = 3;
}

message Service {
  // REQUIRED
  string name = 1;
  
  string version = 2;
   
  map<string, string> extra = 3;
}

// Structure to describe a span of time
message TimeSpan{
  // created time (in ms)
  int64 timestamp = 1;

  // duration (in ms)
  // -1 means the span does NOT end
  int64 duration = 2;
}

enum OperationType {
  OP_NOT_SPECTIFIED = 0;

  // Decrease 
  OP_OUT = 1;

  // Increase
  OP_IN = 2;
}

// ==

enum Code {
  // Not an error; returned on success
  //
  // HTTP Mapping: 200 OK
  SUCCESS = 0;

  // The operation was cancelled, typically by the caller.
  //
  // HTTP Mapping: 499 Client Closed Request
  CANCELLED = 1;

  // Unknown error.  For example, this error may be returned when
  // a `Status` value received from another address space belongs to
  // an error space that is not known in this address space.  Also
  // errors raised by APIs that do not return enough error information
  // may be converted to this error.
  //
  // HTTP Mapping: 500 Internal Server Error
  UNKNOWN_ERROR = 2;

  // The client specified an invalid argument.  Note that this differs
  // from `FAILED_PRECONDITION`.  `INVALID_ARGUMENT` indicates arguments
  // that are problematic regardless of the state of the system
  // (e.g., a malformed file name).
  //
  // HTTP Mapping: 400 Bad Request
  INVALID_ARGUMENT = 3;

  // The deadline expired before the operation could complete. For operations
  // that change the state of the system, this error may be returned
  // even if the operation has completed successfully.  For example, a
  // successful response from a server could have been delayed long
  // enough for the deadline to expire.
  //
  // HTTP Mapping: 504 Gateway Timeout
  DEADLINE_EXCEEDED = 4;

  // Some requested entity (e.g., file or directory) was not found.
  //
  // Note to server developers: if a request is denied for an entire class
  // of users, such as gradual feature rollout or undocumented whitelist,
  // `NOT_FOUND` may be used. If a request is denied for some users within
  // a class of users, such as user-based access control, `PERMISSION_DENIED`
  // must be used.
  //
  // HTTP Mapping: 404 Not Found
  NOT_FOUND = 5;

  // The entity that a client attempted to create (e.g., file or directory)
  // already exists.
  //
  // HTTP Mapping: 409 Conflict
  ALREADY_EXISTS = 6;

  // The caller does not have permission to execute the specified
  // operation. `PERMISSION_DENIED` must not be used for rejections
  // caused by exhausting some resource (use `RESOURCE_EXHAUSTED`
  // instead for those errors). `PERMISSION_DENIED` must not be
  // used if the caller can not be identified (use `UNAUTHENTICATED`
  // instead for those errors). This error code does not imply the
  // request is valid or the requested entity exists or satisfies
  // other pre-conditions.
  //
  // HTTP Mapping: 403 Forbidden
  PERMISSION_DENIED = 7;

  // The request does not have valid authentication credentials for the
  // operation.
  //
  // HTTP Mapping: 401 Unauthorized
  UNAUTHENTICATED = 16;

  // Some resource has been exhausted, perhaps a per-user quota, or
  // perhaps the entire file system is out of space.
  //
  // HTTP Mapping: 429 Too Many Requests
  RESOURCE_EXHAUSTED = 8;

  // The operation was rejected because the system is not in a state
  // required for the operation's execution.  For example, the directory
  // to be deleted is non-empty, an rmdir operation is applied to
  // a non-directory, user balance not enough, etc.
  //
  // Service implementors can use the following guidelines to decide
  // between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`:
  //  (a) Use `UNAVAILABLE` if the client can retry just the failing call.
  //  (b) Use `ABORTED` if the client should retry at a higher level
  //      (e.g., when a client-specified test-and-set fails, indicating the
  //      client should restart a read-modify-write sequence).
  //  (c) Use `FAILED_PRECONDITION` if the client should not retry until
  //      the system state has been explicitly fixed.  E.g., if an "rmdir"
  //      fails because the directory is non-empty, `FAILED_PRECONDITION`
  //      should be returned since the client should not retry unless
  //      the files are deleted from the directory.
  //
  // HTTP Mapping: 400 Bad Request
  FAILED_PRECONDITION = 9;

  // The operation was aborted, typically due to a concurrency issue such as
  // a sequencer check failure or transaction abort.
  //
  // See the guidelines above for deciding between `FAILED_PRECONDITION`,
  // `ABORTED`, and `UNAVAILABLE`.
  //
  // HTTP Mapping: 409 Conflict
  ABORTED = 10;

  // The operation was attempted past the valid range.  E.g., seeking or
  // reading past end-of-file.
  //
  // Unlike `INVALID_ARGUMENT`, this error indicates a problem that may
  // be fixed if the system state changes. For example, a 32-bit file
  // system will generate `INVALID_ARGUMENT` if asked to read at an
  // offset that is not in the range [0,2^32-1], but it will generate
  // `OUT_OF_RANGE` if asked to read from an offset past the current
  // file size.
  //
  // There is a fair bit of overlap between `FAILED_PRECONDITION` and
  // `OUT_OF_RANGE`.  We recommend using `OUT_OF_RANGE` (the more specific
  // error) when it applies so that callers who are iterating through
  // a space can easily look for an `OUT_OF_RANGE` error to detect when
  // they are done.
  //
  // HTTP Mapping: 400 Bad Request
  OUT_OF_RANGE = 11;

  // The operation is not implemented or is not supported/enabled in this
  // service.
  //
  // HTTP Mapping: 501 Not Implemented
  UNIMPLEMENTED = 12;

  // Internal errors.  This means that some invariants expected by the
  // underlying system have been broken.  This error code is reserved
  // for serious errors.
  //
  // HTTP Mapping: 500 Internal Server Error
  INTERNAL = 13;

  // The service is currently unavailable.  This is most likely a
  // transient condition, which can be corrected by retrying with
  // a backoff.
  //
  // See the guidelines above for deciding between `FAILED_PRECONDITION`,
  // `ABORTED`, and `UNAVAILABLE`.
  //
  // HTTP Mapping: 503 Service Unavailable
  UNAVAILABLE = 14;

  // Unrecoverable data loss or corruption.
  //
  // HTTP Mapping: 500 Internal Server Error
  DATA_LOSS = 15;
}